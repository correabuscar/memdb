---
 Cargo.toml    |  4 ++--
 src/lib.rs    | 27 +++++++++++++++------------
 tests/test.rs | 10 +++++-----
 3 files changed, 22 insertions(+), 19 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index df94dce..f98cde7 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -10,7 +10,7 @@ readme = "README.md"
 edition = "2018"
 
 [dependencies]
-parking_lot = "0.11.0"
+dashmap = "4.0.2"
 
 [dev-dependencies]
-runtime = "0.3.0-alpha.4"
+async-std = { version = "1.9.0", features = ["attributes"] }
diff --git a/src/lib.rs b/src/lib.rs
index 405680e..6a9cb83 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -4,7 +4,7 @@
 //! ## Examples
 //!
 //! ```
-//! # #[runtime::main]
+//! # #[async_std::main]
 //! # async fn main() -> std::io::Result<()> {
 //! let mut db = memdb::Memdb::open().await?;
 //! db.set("beep", "boop").await?;
@@ -13,17 +13,15 @@
 //! # Ok(())
 //! # }
 //! ```
+use dashmap::DashMap;
 
-use parking_lot::RwLock;
-
-use std::collections::HashMap;
 use std::io;
 use std::sync::Arc;
 
 /// Key-value database.
-#[derive(Debug, Clone)]
+#[derive(Clone)]
 pub struct Memdb {
-    hashmap: Arc<RwLock<HashMap<Vec<u8>, Vec<u8>>>>,
+    hashmap: Arc<DashMap<Vec<u8>, Vec<u8>>>,
 }
 
 impl Memdb {
@@ -31,7 +29,7 @@ impl Memdb {
     #[inline]
     pub async fn open() -> io::Result<Self> {
         Ok(Self {
-            hashmap: Arc::new(RwLock::new(HashMap::<Vec<u8>, Vec<u8>>::new())),
+            hashmap: Arc::new(DashMap::<Vec<u8>, Vec<u8>>::new()),
         })
     }
 
@@ -43,7 +41,6 @@ impl Memdb {
         value: impl AsRef<[u8]>,
     ) -> io::Result<Option<Vec<u8>>> {
         let hashmap = self.hashmap.clone();
-        let mut hashmap = hashmap.write();
         Ok(hashmap.insert(key.as_ref().to_owned(), value.as_ref().to_owned()))
     }
 
@@ -52,15 +49,21 @@ impl Memdb {
     #[inline]
     pub async fn get(&self, key: impl AsRef<[u8]>) -> io::Result<Option<Vec<u8>>> {
         let key = key.as_ref().to_owned();
-        let hashmap = &self.hashmap.read();
-        Ok(hashmap.get(&key).cloned())
+        let hashmap = &self.hashmap;
+        match hashmap.get(&key) {
+            Some(value) => {
+                let value = value.clone();
+                Ok(Some(value))
+            }
+            None => Ok(None),
+        }
     }
 
     /// Delete a value from the database.
     #[inline]
-    pub async fn del(&mut self, key: impl AsRef<[u8]>) -> io::Result<Option<Vec<u8>>> {
+    pub async fn del(&mut self, key: impl AsRef<[u8]>) -> io::Result<Option<(Vec<u8>, Vec<u8>)>> {
         let key = key.as_ref().to_owned();
-        let hashmap = &mut self.hashmap.write();
+        let hashmap = &mut self.hashmap;
         Ok(hashmap.remove(&key))
     }
 }
diff --git a/tests/test.rs b/tests/test.rs
index 734bd26..487d3b2 100644
--- a/tests/test.rs
+++ b/tests/test.rs
@@ -1,8 +1,8 @@
 use memdb::Memdb;
-use std::error;
+
 use std::io;
 
-#[runtime::test]
+#[async_std::test]
 async fn set_get() -> io::Result<()> {
     let mut db = Memdb::open().await?;
     db.set("beep", "boop").await?;
@@ -11,14 +11,14 @@ async fn set_get() -> io::Result<()> {
     Ok(())
 }
 
-#[runtime::test]
+#[async_std::test]
 async fn threaded_set_get() -> io::Result<()> {
     let db = Memdb::open().await?;
 
     let mut handle = db.clone();
-    runtime::spawn(async move {
+    async_std::task::spawn(async move {
         handle.set("beep", "boop").await?;
-        runtime::spawn(async move {
+        async_std::task::spawn(async move {
             let handle = handle.clone();
             let val = handle.get("beep").await?;
             assert_eq!(val, Some("boop".as_bytes().to_owned()));

